%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Articles
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

@article{reynolds2017solving,
  title={Solving quantified linear arithmetic by counterexample-guided instantiation},
  author={Reynolds, Andrew and King, Tim and Kuncak, Viktor},
  journal={Formal Methods in System Design},
  pages={1--33},
  year={2017},
  publisher={Springer US},
  url       = {http://homepage.divms.uiowa.edu/~ajreynol/fmsd17-instla.pdf},
  doi       = {10.1007/s10703-017-0290-y},
  abstract  = "This paper presents a framework to derive instantiation-based decision procedures
for satisfiability of quantified formulas in first-order theories, including its correctness,
implementation, and evaluation. Using this framework we derive decision procedures for
linear real arithmetic (LRA) and linear integer arithmetic (LIA) formulas with one quantifier
alternation. We discuss extensions of these techniques for handling mixed real and
integer arithmetic, and to formulas with arbitrary quantifier alternations. For the latter, we
use a novel strategy that handles quantified formulas that are not in prenex normal form,
which has advantages with respect to existing approaches. All of these techniques can be
integrated within the solving architecture used by typical SMT solvers. Experimental results
on standardized benchmarks from model checking, static analysis, and synthesis show that
our implementation in the SMT solver CVC4 outperforms existing tools for quantified linear
arithmetic."
}

@article{reynolds2017refutation,
  title={Refutation-based synthesis in SMT},
  author={Reynolds, Andrew and Kuncak, Viktor and Tinelli, Cesare and Barrett, Clark and Deters, Morgan},
  journal={Formal Methods in System Design},
  pages={1--30},
  year={2017},
  publisher={Springer US},
  url="http://homepage.divms.uiowa.edu/~ajreynol/fmsd17.pdf",
  abstract  = "We introduce the first program synthesis engine implemented inside an SMT
solver. We present an approach that extracts solution functions from unsatisfiability proofs
of the negated form of synthesis conjectures. We also discuss novel counterexample-guided
techniques for quantifier instantiation that we use to make finding such proofs practically
feasible. A particularly important class of specifications are single-invocation properties,
for which we present a dedicated algorithm. To support syntax restrictions on generated
solutions, our approach can transform a solution found without restrictions into the desired
syntactic form. As an alternative, we show how to use evaluation function axioms to embed
syntactic restrictions into constraints over algebraic datatypes, and then use an algebraic
datatype decision procedure to drive synthesis. Our experimental evaluation on syntax-guided
synthesis benchmarks shows that our implementation in the CVC4 SMT solver is competitive
with state-of-the-art tools for synthesis."
}

@article{DBLP:journals/tplp/ReynoldsTB17,
  author    = {Andrew Reynolds and
               Cesare Tinelli and
               Clark Barrett},
  title     = {Constraint solving for finite model finding in {SMT} solvers},
  journal   = {{TPLP}},
  volume    = {17},
  number    = {4},
  pages     = {516--558},
  year      = {2017},
  url       = {https://doi.org/10.1017/S1471068417000175},
  doi       = {10.1017/S1471068417000175},
  timestamp = {Wed, 30 Aug 2017 15:38:05 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/tplp/ReynoldsTB17},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  abstract  = "SMT solvers have been used successfully as reasoning engines for automated
verification and other applications based on automated reasoning. Current
techniques for dealing with quantified formulas in SMT are generally incomplete,
forcing SMT solvers to report 'unknown' when they fail to prove the unsatisfiability
of a formula with quantifiers. This inability to return counter-models limits
their usefulness in applications that produce queries involving quantified formulas.
In this paper, we reduce these limitations by integrating finite model finding
techniques based on constraint solving into the architecture used by modern SMT
solvers. This approach is made possible by a novel solver for cardinality constraints,
as well as techniques for on-demand instantiation of quantified formulas. Experiments
show that our approach is competitive with the state of the art in SMT,
and orthogonal to approaches in automated theorem proving."
}

@article{DBLP:journals/jar/ReynoldsB17,
  author    = {Andrew Reynolds and
               Jasmin Christian Blanchette},
  title     = {A Decision Procedure for (Co)datatypes in {SMT} Solvers},
  journal   = {J. Autom. Reasoning},
  volume    = {58},
  number    = {3},
  pages     = {341--362},
  year      = {2017},
  url       = {https://doi.org/10.1007/s10817-016-9372-6},
  doi       = {10.1007/s10817-016-9372-6},
  timestamp = {Sat, 20 May 2017 00:22:32 +0200},
  biburl    = {http://dblp.uni-trier.de/rec/bib/journals/jar/ReynoldsB17},
  bibsource = {dblp computer science bibliography, http://dblp.org},
  abstract  = "We present a decision procedure that combines reasoning about datatypes and
codatatypes. The dual of the acyclicity rule for datatypes is a uniqueness rule that identifies
observationally equal codatatype values, including cyclic values. The procedure decides universal
problems and is composable via the Nelson-Oppen method. It has been implemented
in CVC4, a state-of-the-art SMT solver. An evaluation based on problems generated from
formalizations developed with Isabelle demonstrates the potential of the procedure."
}

%complete
@article {LRT+16,
   url       = "http://www.cs.stanford.edu/~barrett/pubs/LRT+16.pdf",
   author    = "Tianyi Liang and Andrew Reynolds and Nestan Tsiskaridze and Cesare Tinelli and Clark Barrett and Morgan Deters",
   title     = "An Efficient {SMT} Solver for String Constraints",
   journal   = "Formal Methods in System Design",
   publisher = "Springer US",
   keywords  = "String solving; Satisfiability Modulo Theories; Automated Deduction",
   volume    = 48,
   number    = 3,
   pages     = "206--234",
   month     = jun,
   year      = 2016,
   issn      = "1572-8102",
   doi       = "10.1007/s10703-016-0247-6",
   category  = "Journal Articles",
   abstract  = "An increasing number of applications in verification and security 
rely on or could benefit from automatic solvers that can check the satisfiability
of constraints over a rich set of data types that includes character strings.
Until recently, satisfiability solvers for strings were standalone tools 
that could reason only about fairly restricted fragments of the theory 
of strings and regular expressions such as, for instance, strings
of bounded lengths.
These solvers were based on reductions to satisfiability problems 
over other data types, such as bit vectors, or to automata decision problems.
We present a set of algebraic techniques for solving constraints over 
a rich theory of unbounded strings natively, without reduction 
to other problems. 
These techniques can be used to integrate string reasoning into general, 
multi-theory SMT solvers based on the DPLL(T) architecture.
We have implemented them in our SMT solver CVC4 to expand 
its already large set of built-in theories to a theory of strings 
with concatenation, length, and membership in regular languages.
This implementation makes CVC4 the first solver able to accept 
a rich set of mixed constraints over strings, integers, reals, arrays 
and algebraic datatypes.
Our initial experimental results show that, in addition, 
over pure string problems, CVC4 is highly competitive  
with specialized string solvers with a comparable input language."
}

%complete
@article {JB13,
   url       = "http://www.cs.stanford.edu/~barrett/pubs/JB13.pdf",
   author    = "Dejan Jovanovic and Clark Barrett",
   affiliation = {New York University, New York, USA},
   title     = "Being Careful about Theory Combination",
   journal   = "Formal Methods in System Design",
   publisher = {Springer US},
   issn      = {0925-9856},
   volume    = 42,
   number    = 1,
   doi       = "10.1007/s10703-012-0159-z",
   keywords  = {Theory combination; Nelson-Oppen; Satisfiability modulo theories},
   pages     = "67--90",
   month     = feb,
   year      = 2013,
   category  = "Journal Articles",
   abstract  = "One of the main shortcomings of traditional methods for combining theories is
the complexity of guessing the arrangement of variables shared by the individual theories.
This paper presents a reformulation of the Nelson-Oppen method that takes into account
explicit equality propagation and can ignore pairs of shared variables that the theories do
not care about. We show the correctness of the new approach and present care functions
for the theory of uninterpreted functions and the theory of arrays. The effectiveness of the
new method is illustrated by experimental results demonstrating a dramatic performance
improvement on benchmarks combining arrays and bit-vectors."
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Conference Papers
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%complete
@inproceedings{RTJ+17,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/RTJ+17.pdf",
  author    = "Andrew Reynolds and Cesare Tinelli and Dejan JovanoviÄ‡ and Clark Barrett",
  title     = "Designing Theory Solvers with Extensions",
  booktitle = "Proceedings of the 11th International Symposium on Frontiers of Combining Systems (FroCoS '17)",
  series    = "Lecture Notes in Artificial Intelligence",
  volume    = 10483,
  publisher = "Springer",
  editor    = "Clare Dixon and Marcelo Finger",
  pages     = "22--40",
  month     = sep,
  year      = 2017,
  note      = "Brasilia, Brazil",
  category  = "Conference Publications",
  abstract  = "Satisfiability Modulo Theories (SMT) solvers have been developed to
natively support a wide range of theories, including linear arithmetic, bit-vectors,
strings, algebraic datatypes and finite sets. They handle constraints in these theories
using specialized theory solvers. In this paper, we overview the design of
these solvers, specifically focusing on theories whose function symbols are partitioned
into a base signature and an extended signature. We introduce generic techniques
that can be used in solvers for extended theories, including a new context-dependent
simplification technique and model-based refinement techniques. We
provide case studies showing our techniques can be leveraged for reasoning in an
extended theory of strings, for bit-vector approaches that rely on lazy bit-blasting
and for new approaches to non-linear arithmetic."
}

%complete
@inproceedings{MRT+17,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/MRT+17.pdf",
  author    = "Baoluo Meng and Andrew Reynolds and Cesare Tinelli and Clark Barrett",
  title     = "Relational Constraint Solving in SMT",
  booktitle = "Proceedings of the 26th International Conference on Automated Deduction (CADE '17)",
  series    = "Lecture Notes in Artificial Intelligence",
  volume    = 10395,
  publisher = "Springer",
  editor    = "Leonardo de Moura",
  pages     = "148--165",
  month     = aug,
  year      = 2017,
  note      = "Gothenburg, Sweden",
  category  = "Conference Publications",
  abstract  = "Relational logic is useful for reasoning about computational problems
with relational structures, including high-level system design, architectural con-
figurations of network systems, ontologies, and verification of programs with
linked data structures. We present a modular extension of an earlier calculus
for the theory of finite sets to a theory of finite relations with such operations
as transpose, product, join, and transitive closure. We implement this extension
as a theory solver of the SMT solver CVC4. Combining this new solver with
the finite model finding features of CVC4 enables several compelling use cases.
For instance, native support for relations enables a natural mapping from Alloy,
a declarative modeling language based on first-order relational logic, to SMT
constraints. It also enables a natural encoding of several description logics with
concrete domains, allowing the use of an SMT solver to analyze, for instance,
Web Ontology Language (OWL) models. We provide an initial evaluation of our
solver on a number of Alloy and OWL models which shows promising results."
}

@inproceedings{EMT+17,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/EMT+17.pdf",
  author    = "Burak Ekici and Alain Mebsout and Cesare Tinelli and Chantal Keller and Guy Katz and Andrew Reynolds and Clark Barrett",
  title     = "{SMTC}oq: A Plug-In for Integrating {SMT} Solvers into {C}oq",
  booktitle = "Proceedings of the 29th International Conference on Computer Aided Verification (CAV '17)",
  volume    = 10426,
  number    = 1,
  editor    = "Rupak Majumdar and Viktor Kuncak",
  pages     = "126--136",
  series    = "Lecture Notes in Computer Science",
  publisher = "Springer",
  month     = jul,
  year      = 2017,
  note      = "Heidelberg, Germany",
  category  = "Conference Publications",
  abstract  = "
This paper describes SMTCoq, a plug-in for the integration of external
solvers into the Coq proof assistant. Based on a checker for generic first-order
proof certificates fully implemented and proved correct in Coq, SMTCoq offers
facilities to check answers from external SAT and SMT solvers and to increase
Coqâ€™s automation using such solvers, all in a safe way. The current version supports
proof certificates produced by the SAT solver ZChaff, for propositional logic, and
the SMT solvers veriT and CVC4, for the quantifier-free fragment of the combined
theory of fixed-size bit vectors, functional arrays with extensionality, linear integer
arithmetic, and uninterpreted function symbols.
"
}

@inproceedings{RWB+17,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/RWB+17.pdf",
  author    = "Andrew Reynolds and Maverick Woo and Clark Barrett and David Brumley and Tianyi Liang and Cesare Tinelli",
  title     = "Scaling up {DPLL(T)} String Solvers Using Context-Dependent Simplification",
  booktitle = "Proceedings of the 29th International Conference on Computer Aided Verification (CAV '17)",
  volume    = 10426,
  number    = 1,
  editor    = "Rupak Majumdar and Viktor Kuncak",
  pages     = "453--474",
  series    = "Lecture Notes in Computer Science",
  publisher = "Springer",
  month     = jul,
  year      = 2017,
  note      = "Heidelberg, Germany",
  category  = "Conference Publications",
  abstract  = "
Efficient reasoning about strings is essential to a growing number of
security and verification applications. We describe satisfiability checking techniques
in an extended theory of strings that includes operators commonly occurring
in these applications, such as contains, index of and replace. We introduce
a novel context-dependent simplification technique that improves the scalability
of string solvers on challenging constraints coming from real-world problems.
Our evaluation shows that an implementation of these techniques in the SMT
solver CVC4 significantly outperforms state-of-the-art string solvers on benchmarks
generated using PyEx, a symbolic execution engine for Python programs.
Using a test suite sampled from four popular Python packages, we show that
PyEx uses only 41\% of the runtime when coupled with CVC4 than when coupled
with CVC4's closest competitor while achieving comparable program coverage.
"
}

%complete
@inproceedings{KBT+16,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/KBT+16.pdf",
  author    = "Guy Katz and Clark Barrett and Cesare Tinelli and Andrew Reynolds and Liana Hadarean",
  title     = "Lazy Proofs for {DPLL(T)}-Based {SMT} Solvers",
  booktitle = "Proceedings of the 16th International Conference on Formal Methods In Computer-Aided Design (FMCAD '16)",
  editor    = "Ruzica Piskac and Muralidhar Talupur",
  publisher = "FMCAD Inc.",
  pages     = "93--100",
  month     = oct,
  year      = 2016,
  note      = "Mountain View, CA.  {Best paper award.}",
  category  = "Conference Publications",
  abstract  = "With the integration of SMT solvers into analysis
  frameworks aimed at ensuring a system's end-to-end
  correctness, having a high level of confidence in
  these solvers' results has become crucial. For unsatisfiable queries,
  a reasonable approach is to have the solver
  return an independently checkable proof of unsatisfiability.
  We propose a lazy, extensible and robust method for enhancing
  DPLL(T)-style SMT solvers with proof-generation capabilities. Our method
  maintains separate Boolean-level and theory-level proofs, and
  weaves them together into one coherent artifact. Each
  theory-specific solver is called upon lazily, a posteriori, to prove precisely
  those solution steps it is responsible for and that are needed for the final proof.
  We present an implementation of our technique in the CVC4 SMT solver.
  CVC4 can produce unsatisfiability proofs for quantifier-free queries involving
  uninterpreted functions, arrays, bitvectors and combinations thereof. 
  We discuss an evaluation of our tool using industrial benchmarks and benchmarks 
  from the SMT-LIB library, which shows promising results."
}

%complete
@inproceedings{BRBT16,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/BRBT16.pdf",
  author    = "Kshitij Bansal and Andrew Reynolds and Clark Barrett and Cesare Tinelli",
  title     = "A New Decision Procedure for Finite Sets and Cardinality Constraints in {SMT}",
  booktitle = "Proceedings of the 8th International Joint Conference on Automated Reasoning (IJCAR '16)",
  series    = "Lecture Notes in Computer Science",
  volume    = 9706,
  publisher = "Springer International Publishing",
  editor    = "Olivetti, Nicola and Tiwari, Ashish",
  pages     = "82--98",
  doi       = "10.1007/978-3-319-40229-1_7",
  isbn      = "978-3-319-40229-1",
  month     = jun,
  year      = 2016,
  note      = "Coimbra, Portugal",
  category  = "Conference Publications",
  abstract  = "
We consider the problem of deciding the theory of finite sets with cardinality
constraints in a satisfiability modulo theories solver.  Sets are a common
high-level data structure used in programming; thus, such a theory is useful
for modeling program constructs directly. More importantly, sets are a basic
construct of mathematics and thus natural to use when mathematically defining
the properties of a computer system.  We develop a calculus consisting of a
modular combination of a procedure for reasoning about membership constraints
and a procedure for reasoning about cardinality constraints. The reasoning for
cardinality involves tracking how different sets overlap. For efficiency, we
avoid considering Venn regions directly, which has been the approach in earlier
work.  Instead, we develop a novel technique wherein potentially overlapping
regions are considered incrementally. We use a graph to track the interaction
of the different regions.  Early experimental results demonstrate that the new
technique is competitive with previous techniques and scales much better on
certain classes of problems.
"
}


%complete
@inproceedings{HBR+15,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/HBR+.pdf",
  author    = "Liana Hadarean and Clark Barrett and Andrew Reynolds and Cesare Tinelli and Morgan Deters",
  title     = "Fine-grained {SMT} Proofs for the Theory of Fixed-width Bit-vectors",
  booktitle = "Proceedings of the 20th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR '15)",
  series    = "Lecture Notes in Computer Science",
  publisher = "Springer",
  volume    = 9450,
  editor    = {Martin Davis and Ansgar Fehnker and Annabelle McIver and Andrei Voronkov},
  pages     = "340--355",
  month     = nov,
  year      = 2015,
  note      = "Suva, Fiji",
  category  = "Conference Publications",
  abstract  = "Many high-level verification tools rely on SMT solvers to efficiently
discharge complex verification conditions. Some applications require more than
just a yes/no answer from the solver. For satisfiable quantifier-free problems, a
satisfying assignment is a natural artifact. In the unsatisfiable case, an externally
checkable proof can serve as a certificate of correctness and can be mined to
gain additional insight into the problem. We present a method of encoding and
checking SMT-generated proofs for the quantifier-free theory of fixed-width bitvectors.
Proof generation and checking for this theory poses several challenges,
especially for proofs based on reductions to propositional logic. Such reductions
can result in large resolution subproofs in addition to requiring a proof that the
reduction itself is correct. We describe a fine-grained proof system formalized
in the LFSC framework that addresses some of these challenges with the use of
computational side-conditions. We report results using a proof-producing version
of the CVC4 SMT solver on unsatisfiable quantifier-free bit-vector benchmarks
from the SMT-LIB benchmark library."
}

%complete
@inproceedings{LTR+15,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/LTR+15.pdf",
  author    = "Tianyi Liang and Nestan Tsiskaridze and Andrew Reynolds and Cesare Tinelli and Clark Barrett",
  title     = "A Decision Procedure for Regular Membership and Length Constraints over Unbounded Strings",
  booktitle = "Proceedings of the 10th International Symposium on Frontiers of Combining Systems (FroCoS '15)",
  volume    = 9322,
  editor    = "Lutz, Carsten and Ranise, Silvio",
  pages     = "135--150",
  doi       = "10.1007/978-3-319-24246-0_9",
  series    = "Lecture Notes in Artificial Intelligence",
  publisher = "Springer",
  month     = sep,
  year      = 2015,
  note      = "Wroclaw, Poland",
  category  = "Conference Publications",
  abstract  = "We prove that the quantifier-free fragment of the theory of
character strings with regular language membership constraints and linear
integer constraints over string lengths is decidable. We do that by
describing a sound, complete and terminating tableaux calculus for that
fragment which uses as oracles a decision procedure for linear integer
arithmetic and a number of computable functions over regular expressions.
A distinguishing feature of this calculus is that it provides a completely
algebraic method for solving membership constraints which can
be easily integrated into multi-theory SMT solvers. Another is that it
can be used to generate symbolic solutions for such constraints, that is,
solved forms that provide simple and compact representations of entire
sets of complete solutions. The calculus is part of a larger one providing
the theoretical foundations of a high performance theory solver for string
constraints implemented in the SMT solver CVC4."
}

%complete
@inproceedings{RDK+15,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/RDK+15.pdf",
  author    = "Andrew Reynolds and Morgan Deters and Viktor Kuncak and Clark Barrett and Cesare Tinelli",
  title     = "Counterexample Guided Quantifier Instantiation for Synthesis in {SMT}",
  booktitle = "Proceedings of the 27th International Conference on Computer Aided Verification (CAV '15)",
  volume    = 9206,
  number    = 2,
  editor    = "Daniel Kroening and Corina S. P\u{a}s\u{a}reanu",
  pages     = "198--216",
  series    = "Lecture Notes in Computer Science",
  publisher = "Springer",
  month     = jul,
  year      = 2015,
  note      = "San Francisco, CA",
  category  = "Conference Publications",
  abstract  = "We introduce the first program synthesis engine implemented inside
an SMT solver. We present an approach that extracts solution functions from unsatisfiability
proofs of the negated form of synthesis conjectures. We also discuss
novel counterexample-guided techniques for quantifier instantiation that we use
to make finding such proofs practically feasible. A particularly important class of
specifications are single-invocation properties, for which we present a dedicated
algorithm. To support syntax restrictions on generated solutions, our approach
can transform a solution found without restrictions into the desired syntactic
form. As an alternative, we show how to use evaluation function axioms to embed
syntactic restrictions into constraints over algebraic datatypes, and then use an
algebraic datatype decision procedure to drive synthesis. Our experimental evaluation
on syntax-guided synthesis benchmarks shows that our implementation in
the CVC4 SMT solver is competitive with state-of-the-art tools for synthesis."
}

%complete
@inproceedings{BRK+15,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/BRK+15.pdf",
  author    = "Kshitij Bansal and Andrew Reynolds and Tim King and Clark Barrett and Thomas Wies",
  title     = "Deciding Local Theory Extensions via {E}-matching",
  booktitle = "Proceedings of the 27th International Conference on Computer Aided Verification (CAV '15)",
  volume    = 9206,
  number    = 2,
  editor    = "Daniel Kroening and Corina S. P\u{a}s\u{a}reanu",
  pages     = "87--105",
  series    = "Lecture Notes in Computer Science",
  publisher = "Springer",
  month     = jul,
  year      = 2015,
  note      = "San Francisco, CA",
  category  = "Conference Publications",
  abstract  = "Satisfiability Modulo Theories (SMT) solvers incorporate
decision procedures for theories of data types that commonly occur in
software. This makes them important tools for automating verification
problems. A limitation frequently encountered is that verification problems
are often not fully expressible in the theories supported natively by
the solvers. Many solvers allow the specification of application-specific
theories as quantified axioms, but their handling is incomplete outside
of narrow special cases.
In this work, we show how SMT solvers can be used to obtain complete
decision procedures for local theory extensions, an important class
of theories that are decidable using finite instantiation of axioms. We
present an algorithm that uses E-matching to generate instances incrementally
during the search, significantly reducing the number of generated
instances compared to eager instantiation strategies. We have used
two SMT solvers to implement this algorithm and conducted an extensive
experimental evaluation on benchmarks derived from verification conditions
for heap-manipulating programs. We believe that our results are of
interest to both the users of SMT solvers as well as their developers."
}

%complete
@inproceedings{KBT14,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/KBT14.pdf",
  author    = "Tim King and Clark Barrett and Cesare Tinelli",
  title     = "Leveraging Linear and Mixed Integer Programming for {SMT}",
  booktitle = "Proceedings of the 14th International Conference on Formal Methods In Computer-Aided Design (FMCAD '14)",
  publisher = "FMCAD Inc.",
  pages     = "139--146",
  month     = oct,
  year      = 2014,
  note      = "Lausanne, Switzerland",
  category  = "Conference Publications",
  abstract  = "SMT solvers combine SAT reasoning with specialized theory
                  solvers to either find a feasible solution to a set of
                  constraints or prove that no such solution exists.  Linear
                  programming (LP) solvers come from the tradition of
                  optimization, and are designed to find feasible solutions
                  that are optimal with respect to some optimization function.
                  Typical LP solvers are designed to solve large systems
                  quickly using floating point arithmetic.  Because floating
                  point arithmetic is inexact, rounding errors can lead to
                  incorrect results, making inexact solvers inappropriate for
                  direct use in theorem proving.  Previous efforts to leverage
                  such solvers in the context of SMT have concluded that in
                  addition to being potentially unsound, such solvers are too
                  heavyweight to compete in the context of SMT.  In this paper,
                  we describe a technique for integrating LP solvers that
                  dramatically improves the performance of SMT solvers without
                  compromising correctness.  These techniques have been
                  implemented using the SMT solver CVC4 and the LP solver GLPK.
                  Experiments show that this implementation outperforms other
                  state-of-the-art SMT solvers on the QF\_LRA SMT-LIB
                  benchmarks and is competitive on the QF\_LIA benchmarks."
}

%complete
@inproceedings{HBJ+14,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/HBJ+14.pdf",
  author    = "Liana Hadarean and Clark Barrett and Dejan JovanoviÄ‡ and
               Cesare Tinelli and Kshitij Bansal",
  title     = "A Tale of Two Solvers: Eager and Lazy Approaches to Bit-vectors",
  booktitle = "Proceedings of the 26th International Conference on Computer Aided Verification (CAV '14)",
  series    = "Lecture Notes in Computer Science",
  volume    = 8559,
  publisher = "Springer",
  editor    = "Armin Biere and Roderick Bloem",
  pages     = "680--695",
  month     = jul,
  year      = 2014,
  note      = "Vienna, Austria",
  category  = "Conference Publications",
  abstract  = "The standard method for deciding bit-vector constraints is via eager
reduction to propositional logic. This is usually done after first applying powerful
rewrite techniques. While often efficient in practice, this method does not scale on
problems for which top-level rewrites cannot reduce the problem size sufficiently.
A lazy solver can target such problems by doing many satisfiability checks, each
of which only reasons about a small subset of the problem. In addition, the lazy
approach enables a wide range of optimization techniques that are not available
to the eager approach. In this paper we describe the architecture and features
of our lazy solver (LBV). We provide a comparative analysis of the eager and
lazy approaches, and show how they are complementary in terms of the types
of problems they can efficiently solve. For this reason, we propose a portfolio
approach that runs a lazy and eager solver in parallel. Our empirical evaluation
shows that the lazy solver can solve problems none of the eager solvers can and
that the portfolio solver outperforms other solvers both in terms of total number
of problems solved and the time taken to solve them."
}


%complete
@inproceedings{LRT+14,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/LRT+14.pdf",
  author    = "Tianyi Liang and Andrew Reynolds and Cesare Tinelli and Clark Barrett and Morgan Deters",
  title     = "A {DPLL(T)} Theory Solver for a Theory of Strings and Regular Expressions",
  booktitle = "Proceedings of the 26th International Conference on Computer Aided Verification (CAV '14)",
  series    = "Lecture Notes in Computer Science",
  volume    = 8559,
  publisher = "Springer",
  editor    = "Armin Biere and Roderick Bloem",
  pages     = "646--662",
  month     = jul,
  year      = 2014,
  note      = "Vienna, Austria",
  category  = "Conference Publications",
  abstract  = "An increasing number of applications in verification and security rely
on or could benefit from automatic solvers that can check the satisfiability of constraints
over a rich set of data types that includes character strings. Unfortunately,
most string solvers today are standalone tools that can reason only about (some
fragment) of the theory of strings and regular expressions, sometimes with strong
restrictions on the expressiveness of their input language. These solvers are based
on reductions to satisfiability problems over other data types, such as bit vectors,
or to automata decision problems. We present a set of algebraic techniques for
solving constraints over the theory of unbounded strings natively, without reduction
to other problems. These techniques can be used to integrate string reasoning
into general, multi-theory SMT solvers based on the DPLL(T) architecture. We
have implemented them in our SMT solver CVC4 to expand its already large set
of built-in theories to a theory of strings with concatenation, length, and membership
in regular languages. Our initial experimental results show that, in addition,
over pure string problems, CVC4 is highly competitive with specialized string
solvers with a comparable input language."
}

%complete
@inproceedings{KBD13,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/KBD13.pdf",
  author    = "Timothy King and Clark Barrett and Bruno Dutertre",
  title     = "Simplex with Sum of Infeasibilities for {SMT}",
  booktitle = "Proceedings of the 13th International Conference on Formal Methods In Computer-Aided Design (FMCAD '13)",
  publisher = "FMCAD Inc.",
  pages     = "189--196",
  month     = oct,
  year      = 2013,
  note      = "Portland, Oregon",
  category  = "Conference Publications",
  abstract  = "The de facto standard for state-of-the-art real and
integer linear reasoning within Satisfiability Modulo Theories
(SMT) solvers is the Simplex for DPLL(T) algorithm given by
Dutertre and de Moura. This algorithm works by performing a
sequence of local optimization operations. While the algorithm
is generally efficient in practice, its local pivoting heuristics
lead to slow convergence on some problems. More traditional
Simplex algorithms minimize a global criterion to determine the
feasibility of the input constraints. We present a novel Simplexbased
decision procedure for use in SMT that minimizes the sum
of infeasibilities of the constraints. Experimental results show that
this new algorithm is comparable with or outperforms Simplex
for DPLL(T) on a broad set of benchmarks."
}

%complete
@inproceedings{JBdM13,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/JBdM13.pdf",
  author    = "Dejan JovanoviÄ‡ and Clark Barrett and Leonardo de Moura",
  title     = "The Design and Implementation of the Model Constructing Satisfiability Calculus",
  booktitle = "Proceedings of the 13th International Conference on Formal Methods In Computer-Aided Design (FMCAD '13)",
  publisher = "FMCAD Inc.",
  pages     = "173--180",
  month     = oct,
  year      = 2013,
  note      = "Portland, Oregon",
  category  = "Conference Publications",
  abstract  = "We present the design and implementation of the
Model Constructing Satisfiability (MCSat) calculus. The MCSat
calculus generalizes ideas found in CDCL-style propositional SAT
solvers to SMT solvers, and provides a common framework
where recent model-based procedures and techniques can be
justified and combined. We describe how to incorporate support
for linear real arithmetic and uninterpreted function symbols
in the calculus. We report encouraging experimental results,
where MCSat performs competitive with the state-of-the art
SMT solvers without using pre-processing techniques and ad-hoc
optimizations. The implementation is flexible, additional plugins
can be easily added, and the code is freely available."
}

%complete
@inproceedings{RTG+13,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/RTG+13.pdf",
  author    = "Andrew Reynolds and Cesare Tinelli and Amit Goel and Sava Krstic and Morgan Deters and Clark Barrett",
  title     = "Quantifier Instantiation Techniques for Finite Model Finding in {SMT}",
  booktitle = "Proceedings of the 24th International Conference on Automated Deduction (CADE '13)",
  series    = "Lecture Notes in Computer Science",
  volume    = 7898,
  publisher = "Springer Berlin Heidelberg",
  editor    = "Bonacina, Maria Paola",
  pages     = "377-391",
  doi       = "10.1007/978-3-642-38574-2_26",
  isbn      = "978-3-642-38573-5",
  year      = 2013,
  note      = "Lake Placid, NY",
  category  = "Conference Publications",
  abstract  = "SMT-based applications increasingly rely on SMT solvers being able
to deal with quantified formulas. Current work shows that for formulas with quantifiers
over uninterpreted sorts counter-models can be obtained by integrating a
finite model finding capability into the architecture of a modern SMT solver. We
examine various strategies for on-demand quantifier instantiation in this setting.
Here, completeness can be achieved by considering all ground instances over the
finite domain of each quantifier. However, exhaustive instantiation quickly becomes
unfeasible with larger domain sizes. We propose instantiation strategies to
identify and consider only a selection of ground instances that suffices to determine
the satisfiability of the input formula. We also examine heuristic quantifier
instantiation techniques such as E-matching for the purpose of accelerating the
search. We give experimental evidence that our approach is practical for use in
industrial applications and is competitive with other approaches."
}

%complete
@inproceedings{JB11-FroCoS,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/JB11-FroCoS.pdf",
  author    = "Dejan JovanoviÄ‡ and Clark Barrett",
  title     = "Sharing is Caring: Combination of Theories",
  booktitle = "Proceedings of the 8th International Symposium on Frontiers of Combining Systems (FroCoS '11)",
  series    = "Lecture Notes in Computer Science",
  volume    = 6989,
  publisher = "Springer",
  editor    = "Cesare Tinelli and Viorica Sofronie-Stokkermans",
  pages     = "195--210",
  month     = oct,
  year      = 2011,
  note      = {Saarbr\"{u}cken, Germany},
  category  = "Conference Publications",
  abstract  = "One of the main shortcomings of the traditional methods for combining theories is the complexity of guessing the arrangement of the variables shared by the individual theories. This paper presents a reformulation of the Nelson-Oppen method that takes into account explicit equality propagation and can ignore pairs of shared variables that the theories do not care about. We show the correctness of the new approach and present care functions for the theory of uninterpreted functions and the theory of arrays. The effectiveness of the new method is illustrated by experimental results demonstrating a dramatic performance improvement on benchmarks combining arrays and bit-vectors."
}

%complete
@inproceedings{BCD+11,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/BCD+11.pdf",
  author    = "Clark Barrett and Christopher L. Conway and Morgan Deters and
               Liana Hadarean and Dejan JovanoviÄ‡ and Tim King and
               Andrew Reynolds and Cesare Tinelli",
  title     = "{CVC4}",
  booktitle = "Proceedings of the 23rd International Conference on Computer Aided Verification (CAV '11)",
  series    = "Lecture Notes in Computer Science",
  volume    = 6806,
  publisher = "Springer",
  editor    = "Ganesh Gopalakrishnan and Shaz Qadeer",
  pages     = "171--177",
  month     = jul,
  year      = 2011,
  note      = "Snowbird, Utah",
  category  = "Conference Publications",
  abstract  = "CVC4 is the latest version of the Cooperating Validity Checker. A joint project of NYU and U Iowa, CVC4 aims to support the useful feature set of CVC3 and SMT-LIBv2 while optimizing the design of the core system architecture and decision procedures to take advantage of recent engineering and algorithmic advances. CVC4 represents a completely new code base; it is a from-scratch rewrite of CVC3, and many subsystems have been completely redesigned. Additional decision procedures for CVC4 are currently under development, but for what it currently achieves, it is a lighter-weight and higher-performing tool than CVC3. We describe the system architecture, subsystems of note, and discuss some applications and continuing work."
}

%complete
@inproceedings{JB10-LPAR,
  url       = "http://www.cs.stanford.edu/~barrett/pubs/JB10-LPAR.pdf",
  author    = "Dejan JovanoviÄ‡ and Clark Barrett",
  title     = "Polite Theories Revisited",
  booktitle = "Proceedings of the 17th International Conference on Logic for Programming, Artificial Intelligence, and Reasoning (LPAR '10)",
  series    = "Lecture Notes in Computer Science",
  volume    = 6397,
  publisher = "Springer",
  editor    = {Christian G. Ferm\"{u}ller and Andrei Voronkov},
  pages     = "402--416",
  month     = oct,
  year      = 2010,
  isbn      = "3-642-16241-X, 978-3-642-16241-1",
  issn      = "0302-9743",
  note      = "Yogyakarta, Indonesia",
  category  = "Conference Publications",
  abstract  = "The classic method of Nelson and Oppen for combining decision procedures requires the theories to be stably-infinite. Unfortunately, some important theories do not fall into this category (e.g. the theory of bit-vectors). To remedy this problem, previous work introduced the notion of polite theories. Polite theories can be combined with any other theory using an extension of the Nelson-Oppen approach. In this paper we revisit the notion of polite theories, fixing a subtle flaw in the original definition. We give a new combination theorem which specifies the degree to which politeness is preserved when combining polite theories. We also give conditions under which politeness is preserved when instantiating theories by identifying two sorts. These results lead to a more general variant of the theorem for combining multiple polite theories."
}
